[{"content":"常见算法 查找算法（7种） 基本查找 二分/折半查找 分块查找 插值查找（数据分布比较均匀，否则反而效率更差） mid = min + (key-arr[min]) / (arr[max]-min) * (max-min) 斐波那契查找 mid = min + 黄金分割点左半边长度 - 1 注：黄金比例为1:0.618 树表查找 哈希查找 基本查找 核心：从0索引开始挨个往后查找\n1 2 3 4 5 6 7 8 public static boolean basicSearch(int[] arr ,int number){ for(int i = 0; i \u0026lt; arr.length; i++){ if(arr[i] == number){ return true; } } return false; } （折半/二分）查找 前提条件：数组中的数据必须是有序的\n核心逻辑：每次排除一半的查找范围\nmin和max表示当前要查找的范围 mid是在min和max中间 如果要查找的元素在mid左边，缩小范围时，min不变，max等于mid减1 如果要查找的元素在mid右边，缩小范围时，max不变，min等于mid加1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int binarySearch(int[] arr, int number){ int min = 0; int max = arr.length -1; while(true){ if(min \u0026gt; max){ return -1; } int mid = (min + max)/2; if(arr[mid] \u0026gt; number){ max = mid - 1; }else if(arr[mid] \u0026lt; number){ min = mid + 1; }else { return mid; } } } 分块查找 分块原则1: 前一块中的最大数据，小于后一块中的所有数据（块内无序，快间有序）\n分块的原则2: 快数数量一般等于数字的个数开根号\n核心思路：先确定要查找的元素在哪一块，然后在块内挨个查找\n排序算法（10种） 冒泡排序 选择排序 插入排序 快速排序 希尔排序 归并排序 堆排序 计数排序 桶排序 基数排序 冒泡排序 相邻的数据两两比较，小的放前面，大的放后面 第一轮比较完毕之后，最大值已确定，第二轮可以少循环一次，后面以此类推 如果数组中有n个数据，总共需执行n-1轮代码 选择排序 原理：从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，以此类推\n插入排序 原理：将数组分为有序和无序两组，遍历无序数据，将元素插入有序序列中即可\n将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\nN的范围：0～最大索引\n快速排序 原理：\n将排序范围中的第一个数字作为基准数，再定义两个变量start，end start从前往后找比基准数大的，end从后往前找比基准数小的 找到之后交换start和end指向的元素，并循环这一过程，直到start和end处于同一个位置，该位置是基准数在数组中应存入的位置，再让基准数归位 归位后的效果：基准数左边的比基准数小，基准数右边的比基准数大 第一轮：把0索引的数字作为基数，确定基准数在数组中正确的位置\n比基准数小的全部在左边，比基准数大的全部在右边\n递归 定义：递归指的是方法中调用方法本身的现象\n作用：把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n字符串匹配算法 基本查找 KMP算法 ","description":"","id":4,"section":"posts","tags":[""],"title":"Java算法及其应用","uri":"https://qqnv.com/zh/posts/java%E7%AE%97%E6%B3%95/"},{"content":"基础类型 计算机的存储单元 计算机存储设备的最小单元叫位（bit），通常用b表示\n计算机最小的存储单元叫字节（byte），B表示，由连续的8个位组成\n1B（字节）= 8bit\t1kb = 1024B\n数据类型 基本数据类型 数值型 整数（byte, short, int, long） 浮点数（float, double） 字符（char） 非数值型 布尔（boolean） 引用数据类型 类（class） 接口（interface） 数组（[]） 数据类型 关键字 内存占用 取值范围 整数 byte 1 -128～127 short 2 -32768～32767 int 4 -2的31次方～2的31次方-1 long 8 -2的63次方～2的63次方-1 浮点数 float 4 负数-3.402823E+38～-1.401298E-45\n正数1.401298E-45～3.402823E+38 double 8 负数-1.797693E+308～-4.9000000E-324\n正数4.9000000E-324～1.797693E+308 字符 char 2 0~65535 布尔 boolean 1 true、false 说明：E+38表示乘以10的38次方，E-45表示乘以10的负45次方\nJava内存模型 当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。不存在创建新的，存在则复用\n基本数据类型比较的事数据值 引用数据类型比较的是地址值\nJava关键字static理解 被static修饰的成员变量叫静态变量\n特点：被该类所有对象共享，不属于对象，属于类，随着类的加载而加载，优先于对象存在可被类名和对象名调用，存放在堆内存静态区中\n被static修饰的成员方法叫静态方法\n特点：多用在测试类和工具类中，JavaBean类中很少使用\n工具类私有化构造方法，目的是不让外界创建它的对象，里面的方法定义为静态方便调用\n静态内部类和非静态内部类区别：是否持有外部类的状态，静态内部类持有外部类的实例\n静态方法只能访问静态变量和静态方法 非静态方法可以访问静态变量或静态方法，也可以访问非静态成员变量和非静态成员方法 静态方法中没有this关键字 Java关键字final理解 final修饰类，该类不能被继承，且该类中所有方法都被隐式指定为final方法 final修饰的方法不能被重写\n一个类的private方法被隐式指定为final方法 final修饰成员变量，必须要赋初始值，且只能初始化一次 如果修饰的是基本类型，则变量值不能改变 如果修饰的是引用类型，则引用的地址值不能更改，但这个引用所指的对象的内容可以改变 抽象类和接口 抽象类 抽象类的设计目的，是代码复用。当不同的类具有相同的行为（记为行为集合A），且其中一部分行为的实现方式一样时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类都实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现，正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用A-B时，无法执行）。\n实现了一部分协议的半成品 可以有状态，可以有方法实现 必须由子类继承后使用 接口 接口设计的目的，是对类行为的约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制不同的类有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。\n直观理解就是一种约定 不能有状态 必须由类进行实现后使用 共性 比较抽象，不能直接实例化 有需要子类（实现类）实现的方法 父类（接口）变量可以接收子类（实现类）的实例赋值 区别 抽象类是对类本质的抽象，表达的是is a的关系，比如：BMW is a Car，抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。\n接口是对行为的抽象，表达的是like a的关系，比如：Bird like a Aircraft（像飞行器一样可以飞），但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。\n使用场景：当你关注一个事物本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性，虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口，在设计阶段会降低难度。\n抽象类有状态，接口不能有状态 抽象类有方法实现，接口只能有无状态的默认实现\n抽象类可以有普通成员函数，接口中只能存在public abstract方法\n抽象类中的成员变量可以是各种类型的，接口中成员变量只能是public static final类型的 抽象类只能单继承，接口可以多实现 抽象类反应本质，接口体现能力 接口中成员的特点\n成员变量 只能是常量，默认修饰符public static final 构造方法没有 成员方法 只能是抽象方法，默认修饰符public abstract jdk7以前，接口中只能定义抽象方法 jdk8新特性，接口中可以定义有方法体的方法（默认方法（修饰符default）或静态方法（修饰符static）） jdk9新特性，接口中可以定义私有方法（可以是静态（给静态方法服务）或非静态（给默认方法服务）） 接口中如果没有成员，那么它就是个标记性接口 接口代表规则，是行为的抽象，想要让哪个累拥有某个行为，让这个类实现对应接口就行 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态 适配器模式 当一个接口中抽象方法过多，但是我们只要使用其中一部分的时候，可以用适配器实现\n编写中间类adapter，实现对应接口，对接口中的抽象方法进行空实现，让真正的实现类继承中间类，并重写需要用的方法，为了避免其他类去创建适配器类的对象，适配器用abstract修饰\n内部类 成员内部类 写在成员位置，在成员内部类里，jdk16以前不能定义静态变量，16开始才可以定义 两种创建方式，一种是内部提供对象的方法(当内部类用pravite修饰时)\n另一种是Outer.Inner oi = new Outer().new Inner(); 静态内部类 用static修饰符修饰的内部类 直接创建即可Outer.Inner oi = new Outer.Inner(); 若调用静态方法则直接Outer.Inner.show();\n若调用非静态方法则要先创建对象，再调用 局部内部类 定义在方法中 外界无法直接使用，需在方法内部创建对象并调用 该类可以直接访问外部类的成员和方法内的局部变量 匿名内部类 隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置 格式是new 类名或接口名(){重写方法;}; 包含了继承或实现，方法重写，创建对象，整体是一个类的子类对象或接口的实现类对象 使用场景：当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码 equels String中的equals方法先判断参数是否为字符串，如果是则判断内部属性，如果不是直接返回false\nObject中的equals方法默认使用==比较两个对象的地址值\n若想比较两个对象的属性值，则需要重写Object中的equals方法\nObject object中的克隆默认是浅克隆，深克隆可以利用gson库实现\nGson gson = new Gson(); //把对象变成一个字符串 String s = gson.toJson(u1); //再把字符串变回对象 User user = gson.fromJson(s,User.class); 需重写object中的clone() 让JavaBean类实现Cloneable接口 创建原对象并调用clone() 浅克隆：基本数据类型直接拷贝，引用数据类型拷贝地址值\n深克隆：基本数据类型直接拷贝，字符串复用串池数据，其他引用数据类型会重新创建对象，并拷贝里面的数据，将新内存地址赋值给新对象\nBigInteger 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取 如果BigInteger表示的数字超出long的范围，可以用构造方法获取 对象一旦创建，BigInteger内部记录的值不能发生改变 只要进行计算都会产生一个新的BigInteger对象 BigInteger表示一个大整数常见方法有：\n加：add 减：subtract 乘：multiply 除：divide、divideAndRemainder\n比较：equals、max、min\n次幂：pow\n转成整数：intValue、longValue等\nBigDecima 用于小数的精确计算 用于表示很大的小数 如果BigInteger表示的数字没有超出Double的范围，可以用.valueof() 如果BigInteger表示的数字超出Double 的范围，可以new出来 正则表达式(Pattern) 作用\n校验字符串是否满足规则 在一段文本中查找满足要求的内容 Matcher：文本匹配器\n正则表达式在字符串方法中的使用\n方法名 说明 public String[] matches(String regex) 判断字符串是否满足正则表达式规则 public String replaceAll(String regex, String newStr) 按照正则表达式规则进行替换 public String[] split(String regex) 按照正则表达式规则切割字符串 时间类 JDK8以前 Date new Date()获取当前时间 new Date(0L)获取时间原点 （1970年1月1日8:00） SimpleDateFormat format(\u0026quot;\u0026quot;)将时间转化为给定格式的时间字符串 parse(\u0026quot;\u0026quot;)解析字符串的文本转换为时间对象 Calendar 可以单独获取修改时间中的年月日，该类是个抽象类，不能直接创建对象\n该类获取的月份要+1\n方法名 说明 public static Calendar getInstance() 根据系统不同的时区来获取不同的日历对象 public final Date getTime() 获取日期对象 public final Date setTime(Date date) 给日历设置日期对象 public long getTimeInMillis() 拿到时间毫秒值 public void setTimeInMillis(long mills) 给日历设置时间毫秒值 public int get(int field) 取日历中某个字段信息 public void set(int field,int value) 修改日历的某个字段信息 public void add(int field,int amount) 为某个字段增加/减少指定的值 ZoneId时区 方法名 说明 static Set getAvailableZoneIds() 获取Java中支持的所有时区 static ZoneId systemDefault() 获取系统默认时区 static ZoneId of(String zoneId) 获取一个指定时区 JDK8及以后 Date类 ZoneId：时区\nInstant：时间戳\nZoneDateTime：带时区的时间\n日期格式化类 DateTimeFormatter：用于时间的格式化和解析\n日历类 LocalDate：年月日\nLocalTime：时分秒\nLocalDateTime：年月日时分秒\n工具类 Duration：时间间隔（时分秒纳秒）\nPeriod：时间间隔（年月日）\nChronoUnit：时间间隔（所有单位）\n包装类 在jdk5以前的两种创建包装类对象：\nInteger i = new Integer(1); 每次创建都会创建一个新的对象 Integer i = Integer.valueOf(1);-128～127之间会复用对象，底层会把对象都创建好放在一个长为256的数组里以便复用 jdk5以后会自动拆箱、自动装箱\nInteger 方法名 说明 public static String toBinaryString(int i) 得到二进制 public static String toOctalString(int i) 得到八进制 public static String toHexString(int i) 得到十六进制 public static int parseInt(String s) 将字符串类型的整数转成int类型的整数 ","description":"","id":5,"section":"posts","tags":[""],"title":"Java基础","uri":"https://qqnv.com/zh/posts/java%E5%9F%BA%E7%A1%80/"},{"content":"本地博客 安装Hugo brew install hugo\n建立新站点 hugo new site blog\n添加主题 cd blog git init git submodule add https://github.com/budparr/gohugo-theme-\u0026lt;YOURTHEME\u0026gt;.git themes/\u0026lt;YOURTHEME\u0026gt; 新建文章 hugo new posts/article.md\n开启本地服务 hugo server\nGitHub部署Hugo 创建GitHub项目 项目名称为xxx.github.io（xxx为你想要的项目名）\n关联Github hugo --theme=主题名称 --baseUrl=\u0026quot;https://xxx.github.io\u0026quot;(xxx表示你的github..) --buildDrafts cd public git init . git add . git commit -m \u0026quot;xxx\u0026quot; git remote add origin https://github.com/xxx/xxx.github.io.git git push -u origin master github为该项目配置page及域名，输入域名即可访问 博客修改更新 博客根目录创建deploy.sh并输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/sh # If a command fails then the deploy stops set -e # Print out commands before executing them set -x printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. hugo -t 主题文件夹名称 --buildDrafts # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git pull # Push source and build repos. git push # Back to the origin folder # cd .. # rm -rf public 博客根目录命令行执行./deploy.sh \u0026quot;网站更改的内容\u0026quot;\n","description":"静态博客，官方文档写的很好，部署简洁，不需root权限","id":6,"section":"posts","tags":["hugo","blog"],"title":"Hugo博客搭建","uri":"https://qqnv.com/zh/posts/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"环境变量配置 配置过程 命令行输入：echo $PATH，查看已配置的环境变量 sudo vi ~/.bash_profile，进入环境变量配置文件 默认是只读状态，键入i进入编辑状态 编辑完成后，键入esc，然后键入:wq保存即可 配置完成后可能需要重启才能生效，若想立即生效，需键入source ~/.bash_profile即可 环境变量加载顺序 /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 前两个是系统级别的，系统启动就会加载，后面三个是用户级别，按照从前往后的顺序读取，若bash_profile存在，后面的几个文件就会被忽略不读了，~/.bashrc没有上述规则，它是bash shell打开的时候载入的。\n也就是说在当前用户的目录下，如果又了.bash_profile文件就不会去加载.bashrc文件。\n所以如果要能正常加载.bashrc文件，需要在.bash_profile文件的最末尾上加入如下语句：\n1 2 3 if [ -f ~/.bashrc ]; then source ~/.bashrc fi 全局设置 /etc/paths （全局建议修改这个文件）\n编辑时一行一个路径。\n注意：输入环境变量时，不用一个一个输入，只要拖拽文件夹到 Terminal 里就可以了。 /etc/profile （建议不修改这个文件）\n全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 /etc/bashrc （一般在这个文件中添加系统级环境变量）\n全局（公有）配置，bash shell 执行时，不管是何种方式，都会读取此文件。 git版本升级 安装Homebrew，终端输入/usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; 安装最新版gitbrew install git 配置环境变量，在环境变量配置文件中添加\nexport PATH=\u0026quot;/usr/local/Cellar/git/2.32.0_1/bin:$PATH\u0026quot;\n其中版本号可到/usr/local/Cellar/git下查看并修改 键入source ~/.bash_profile使配置生效，输入git --version即可查看最新版本号 adb环境变量配置 用户目录下.bash_profile中添加\nexport PATH=${PATH}:/Users/qqnv/Library/Android/sdk/platform-tools export PATH=${PATH}:/Users/qqnv/Library/Android/sdk/tools 盒盖禁止休眠 命令行执行sudo pmset -a disablesleep 1\n反之sudo pmset -a disablesleep 0\n","description":"Mac的那些事儿","id":7,"section":"posts","tags":["mac"],"title":"Mac开发配置","uri":"https://qqnv.com/zh/posts/mac%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"},{"content":"安装git 安装node.js 安装本地hexo环境 打开命令行工具依次执行：\nnpm install hexo-cli -g hexo init blog cd blog npm install hexo server 关联Github 配置SSH 创建和github同名的项目，项目名必须为github名 命令行输入cd ~/. ssh检查本机已存在的ssh密钥，若提示No such file or directory，则说明是第一次使用git，否则说明ssh曾经配置过，直接执行第7步 命令行执行git config –global user.name “username”//输入注册时的项目名，命令行执行git config –global user.email “yourname@yourmail.com“//填写注册邮箱 命令行输入ssh-keygen -t rsa -C ‘第3步中的邮箱’ 命令行输入cat ~/.ssh/id_rsa.pub查看本机的ssh配置 进入GitHub主页，进入settings，左侧选SSH and GPG keys，将第5步shh配置内容粘贴到对应位置，title随便填个 命令行输入ssh -T git@github.com,提示You are successfully authenticated, but GitHub does not provide shell access. 即为成功 配置根目录_config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 title: **My Blog** #博客名称 subtitle: to be continued... #副标题 description: My blog #给搜索引擎看的，对网站的描述，可以自定义 author: **Yourname** #作者，在博客底部可以看到 email: yourname@yourmail.com #你的联系邮箱 language: **zh-CN** #中文，如果不填则默认英文 timezone: Asia/Shanghai url: https://yoursite.com deploy: type: git #部署的服务器类型 repo: #username为你的github名称 github: https://github.com/username/username.github.io.git name: username email: yourname@yourmail.com #你的电子邮件 branch: master 上传到github 根目录下依次执行：\nnpm install hexo-deployer-git –save hexo d hexo g 浏览器输入username.github.io即可访问\n更换主题 GitHub上下载想要的主题放在themes目录下 更改_config.yml中的theme属性为下载的主题文件夹名 返回主目录命令行依次执行 hexo generate hexo deploy 等待一分钟刷新页面即可 Hexo常用命令 npm install hexo-cli -g（Hexo安装） hexo init blog（Hexo生成本地博客） npm install（安装依赖包） hexo server（启动本地服务器，开启预览访问端口（默认端口4000，’ctrl + c’关闭server）） hexo new “postName” （新建文章） hexo new page “pageName” （新建页面） hexo generate （生成静态页面至public目录） hexo deploy （部署到GitHub） hexo help （查看帮助） hexo version （查看Hexo的版本） 简写\nhexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo s -g（生成本地预览） hexo d -g（生成并上传到github） Hexo自定义页面做首页 新建一个仓库，可取名blog 原博客根目录下修改_config.yml的内容 1 2 url: https://xxx.com root: /blog/ 1 2 deploy: repo: https://github.com/blog.git 重新部署博客 博客会重新上传到blog仓库中\n清空原来的仓库，上传自定义的首页代码 更改github默认page ","description":"静态博客，有很方便的部署命令，可以做到一条命令部署到github上","id":8,"section":"posts","tags":["hexo","blog"],"title":"Hexo博客搭建","uri":"https://qqnv.com/zh/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"最令人怵目惊心的一件事，是看着钟表上的秒针一下一下地移动，每移动一下就是表示我们的寿命已经缩短了一部分。再看看墙上挂着的可以一张张撕下的日历，每天撕下一张就是表示我们的寿命又缩短了一天。因为时间即生命。没有人不爱惜他的生命，但很少人珍视他的时间。如果想在有生之年做一点什么事，学一点什么学问，充实自己，帮助别人，使生命成为有意义，不虚此生，那么就不可浪费光阴。这道理人人都懂，可是很少人真能积极不懈地利用他的时间。\n我自己就是浪费了很多时间的一个人。我不打麻将，我不经常地听戏看电影，几年中难得一次，我不长时间看电视，通常只看半个小时，我也不串门子闲聊天。有人问我：“那么你大部分时间都做了些什么呢？”我痛自反省，我发现，除了职务上的必须人情上所不能免的活动之外，我的时间大部分都浪费了。我应该集中精力，读我所未读过的书，我应该利用所有的时间，写我所要写的东西，但是我没能这样做。我的好多时间都糊里糊涂地混过去了，“少壮不努力，老大徒伤悲。”例如我翻译了莎士比亚，本来计划于课余之暇每年翻译两部，二十年即可完成，但是我用了三十年，主要原因是因为懒。翻译之所以完成，主要的是因为活得长久，十分惊险。翻译完成之后，虽然仍有工作计划，但体力渐衰，有力不从心之感。假使年轻的时候鞭策自己，如今当有较好或较多的表现。然悔之晚矣。\n再例如，作为一个中国人，经书不可不读。我年过三十才知道读书自修的重要。我披阅，我圈点，但是恒心不足，时做时辍。五十以学易，可以无大过矣，我如今年过八十，还没有接触过《易经》，说来惭愧。史书也很重要。我出国留学的时候，父亲买了一套同文石印的前四史，塞满了我的行箧（qie）的一半空间，我在外国混了几年之后又把四史原封带回来了。直到四十年后才鼓起勇气读了《通鉴》一遍。现在我要读的书太多，深感时间有限。\n无论做什么事，健康的身体是基本条件。我在学校读书的时候，有所谓“强迫运动”，我踢破过几双球鞋，打断过几支球拍。因此侥幸维持下来最低限度的体力。老来打过几年太极拳，目前则以散步活动筋骨而已。寄语年轻朋友，千万要持之以恒地从事运动，这不是嬉戏，不是浪费时间。健康的身体是做人做事的真正的本钱。\n人的天性大致是差不多的，但是在习惯方面却各有不同，习惯是慢慢养成的，在幼小的时候最容易养成，一旦养成之后，要想改变过来还不很容易。\n例如说：清晨早起是一个好习惯，这也要小时候养成，很多人从小就贪睡懒觉，一遇节假日便要睡到日上三竿还高卧不起，平时也是不肯早起，往往蓬首垢面的就往学校跑，结果还是迟到，这样的人长大了之后也常是不知振作，多半不能有什么成就。祖逖（ti）闻鸡起舞。那才是志士奋励的榜样。\n我们中国人最重礼，因为礼是行为的轨范。礼要从家庭里做起。姑举一例：为子弟者“出必告，反必面”，这一点点对长辈的起码的礼，我们是否已经每日做到了呢？我看见有些个孩子们早晨起来对父母视若无睹，晚上回到家来如入无人之境，遇到长辈常常横眉冷目，不屑搭讪。这样的跋扈乖戾之气如果不早早地纠正过来，将来长大到社会服务，必将处处引起摩擦不受欢迎。我们不仅要对长辈要恭敬有礼，对任何人都应该维持相当的礼貌。\n大声讲话，扰及他人的宁静，是一种不好的习惯。我们试自检讨一番，在别人读书工作的时候是否有过喧哗的行为？我们要随时随地为别人着想，维持公共的秩序，顾虑他人的利益，不可放纵自己，在公共场合人多的地方，要知道依次排队，不可争先恐后地去乱挤。\n时间即是生命。我们的生命是一分一秒地在消耗着，我们平常不大觉得，细想起来实在值得警惕。我们每天都有许多的零碎时间于不知不觉中浪费掉了。若能养成一种利用闲暇的习惯，一遇空闲，无论其多么短暂，都利用之做一点有益身心之事，则积少成多必有成。常听人讲起“消遣”二字，最是要不得，好像是时间太多无法打发的样子，其实人生短促极了，哪里会有多余的时间待人“消遣”？陆放翁有句云：“待饭未来还读书。”我知道就有人常利用这“待饭未来”的时间读了不少大书。古人所谓“三上之功”，枕上、马上、厕上，虽不足为训，其用意是在劝人不要浪费光阴。\n吃苦耐劳是我们这个民族的标志。古圣先贤总是教训我们要能过得简朴的生活，所谓“一箪食，一瓢饮”，就是形容生活状态之极端的刻苦，所谓“嚼得菜根”，就表示一个有志的人能耐得清寒。恶衣恶食，不足为耻，丰衣足食，不足为荣，这个在个人修养上是应有的认识。罗马帝国盛时的一位皇帝，MarcusAurelius，他从小就摒绝一切享受，从来不参观当时风靡全国的赛车比武之类的娱乐，终其身成为一位严肃的苦修派的哲学家，而且也建立了不朽的事功。这是很值得令人钦佩的。我们中国是一个穷的国家，所以我们更应该体念艰难，弃绝一切奢侈，尤其是外国来的奢侈。宜从小就养成简朴的习惯，更要知道物力维艰，竹头木屑，皆宜爱惜。\n以上数端不过是偶然拈来，好的习惯千头万绪，“勿以善小而不为”。习惯养成之后，便毫无勉强，临事心平气和，顺理成章。充满良好习惯的生活，才是合于“自然”的生活。\n以上是摘自梁实秋先生《雅舍小品》的几段文字，于昨日睡前读后颇有感慨，故摘录至此，与君共勉。\n","description":"没有人不爱惜他的生命，但很少人珍视他的时间","id":9,"section":"posts","tags":["article"],"title":"《雅舍小品》节选","uri":"https://qqnv.com/zh/posts/%E9%9B%85%E8%88%8D%E5%B0%8F%E5%93%81%E8%8A%82%E9%80%89/"},{"content":"为什么Android的UI操作是不安全的 首先要知道什么是线程安全，什么是线程不安全\n线程安全：多个线程访问时，采用加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能直接进行访问直到线程读取完，其他线程才可以使用，不会出现数据不一致或数据污染\n线程不安全：就是不采用加锁机制，也就是不提供数据访问保护，可以多个线程同时进行访问，可能产生多个线程先后更改数据造成所得到的数据时脏数据\n在Android中，如果有多个线程都在同时更改UI，会造成界面混乱不堪。如果采用加锁机制会降低运行效率，所以Android选择的线程不安全但性能好这个方式。即Android出于对性能的考虑所以UI线程时不安全的。线程不安全带来的问题就是不安全，所以Android设计主线程MainThread为单线程模型。规定只能在主线程中更改UI元素，子线程想更改UI必须通知主线程。这就涉及到了线程间通信，也就出现了Handler消息机制来实现进程间的通信\n","description":"Android的那些事儿","id":10,"section":"posts","tags":["android"],"title":"Android基础","uri":"https://qqnv.com/zh/posts/android%E5%9F%BA%E7%A1%80/"},{"content":"国内GitHub无法访问或访问慢 进入DNS检测工具 在检测栏输入github.com 把检测列表里的TTL值最小的IP输入到hosts里，并对应写上github官网域名\nhost文件打开方式 方法一：打开finder，快捷键【shift+command+g】，输入/private,打开etc即可找到hosts文件 方法二：打开终端，输入vim /etc/hosts即可打开该文件 终端输入sudo killall -HUP mDNSResponder使文件生效 Git命令 设置签名 项目级别（尽在当前本地库有效） 1 2 git config user.name username git config user.email email 系统级别（仅在当前登录的操作系统用户有效） 1 2 git config --global user.name username git config --global user.name email 初始化本地库 进入文件目录 git init初始化本地库 查看工作区状态 git status\n添加文件到暂存区 git add filename添加指定文件\ngit add .添加所有文件\n提交到本地库 git commit -m 'commit message' fileName\n查看历史记录 1 2 3 4 5 6 git log git reflog #常用 git log --greph #图形显示，更直观 git log --pretty=oneline #漂亮一行显示 git log --oneline #简洁显示 说明：HEAD@{移动到当前版本需要多少步} 版本前进或后退 基于索引值推荐\n1 git reset -- hard 版本号 #回到该版本 使用^符号只能后退\n1 git reset --hard HEAD^ #几个^表示回退几步 使用～符号只能后退\n1 git reset --hard HEAD~n #n代表回退几步 reset的三个参数\n1 2 3 4 5 6 7 8 9 soft: - 仅本地库移动HEAD指针 mixed: - 在本地库移动HEAD指针 - 重置暂存区 hard: - 在本地库移动HEAD指针 - 重置暂存区 - 重置工作区 分支管理 命令 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支中 git branch -b 分支名 创建分支并直接切换到该分支 git branch -d 分支名 删除分支 解决冲突：\n修改冲突文件 添加到缓存区git add 文件名 提交到本地库git commit -m \u0026lsquo;日志信息\u0026rsquo; 注意：后面不能带文件名 关联Github 创建远程库别名 1 2 git remote -v #查看远程库地址别名 git remote add 别名 远程地址 推送到远程仓库 1 2 git push 别名 分支名 git push -u 别名 分支名 #-u指定默认主机 克隆远程仓库 git clone 远程地址克隆下来后不要在主分支里做开发\n会执行拉取代码、初始化本地仓库、创建别名操作\n拉取 1 2 3 4 pull = fetch + merge git fetch 别名 分支名 git merge 别名 分支名 git pull 别名 分支名 冲突解决 不是基于远程库最新版做的修改不能推送，必须先pull下来解决冲突才能推送\n解决冲突后提交的文件不能带文件名\n本地库强制覆盖远程库：git push -f \u0026ndash;set-upstream origin master:master\nGit相关问题及解决办法 remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n解决办法：重新登录github账号，密码使用token，token在github中生成，然后复制保存留用 若push时不提示输入用户名或密码\n解决办法：命令行输入git config \u0026ndash;system \u0026ndash;unset credential.helper\nerror: could not lock config file /usr/local/git/etc/gitconfig: Permission denied\n解决办法：命令行输入sudo chgrp -R admin /usr/local及sudo chmod -R g+w /usr/local IDEA配置使用Git 初始化本地库\nVCS -\u0026gt; Import into Version Control 项目变红 VCS变成Git 添加到暂存区\n右键项目 -\u0026gt;Git -\u0026gt; Add 项目变绿 提交本地库\n右键项目 -\u0026gt;Commit Directory 提交后项目恢复原色 ","description":"Git配置及常见命令","id":11,"section":"posts","tags":["git"],"title":"代码托管Git","uri":"https://qqnv.com/zh/posts/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1git/"},{"content":"介绍 喜爱编程\n技术总结\n热爱旅行\n联系 邮箱：qqnvblog@gmail.com\nQQ：25519490\n","description":"About Page","id":12,"section":"","tags":null,"title":"About","uri":"https://qqnv.com/zh/about/"},{"content":"Jetpack是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种Android版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。\n为何使用Jetpack\n遵循最佳做法\nAndroid Jetpack组件采用最新的设计方法构建，具有向后兼容性，可以减少崩溃和内存泄露。 消除样板代码\nAndroid Jetpack可以管理各种繁琐的Activity（如后台任务、导航和生命周期管理），以便您可以专注于打造出色的应用。 减少不一致\n这些库可在各种Android版本和设备中以一致的方式运作，助您降低复杂性。 LifeCycle 作用 帮助开发者建立可感知生命周期的组件 组件在其内部管理生命周期，从而降低模块耦合度 降低内存泄漏发生的可能性 Activity、Fragment、Service、Application均有LifeCycle支持 应用 使用LifeCycle解耦页面与组件 使用LifeCycleService解耦Service与组件 使用ProgressLifeServiceOwner监听应用程序生命周期 ViewModel 要解决的问题 瞬态数据丢失（保证屏幕旋转之后用户数据仍然存在）\nViewModel的生命周期特性：独立与配置变化，无论Activity生命周期怎么变化，对ViewModel数据都没有影响，finish()时数据才会清空 异步调用的内存泄漏 类膨胀提高维护难度和测试难度 作用 是介于View（视图）和Model（数据模型）之间的桥梁 使视图和数据能够分离，也能保持通信 注意的问题 不要向ViewModel中传入Context，会导致内存泄漏 如果要使用Context，请使用AndroidViewModel中的Application LiveData 作用 在ViewModel的数据发生变化时通知页面\n优点 确保界面符合数据状态 不会发生内存泄漏 不会因为Activity停止而导致内存崩溃 不再需要手动处理生命周期 数据始终保持最新状态 适当的配置更改 共享资源 DataBinding 意义 让布局文件承担了部分原本属于页面的工作，使页面与布局耦合度进一步降低\n优势 不再需要findViewById，项目更加简洁，可读性更高 布局文件可以包含简单的业务逻辑 Room Entity：实体类，对应的是数据库的一张表结构使用注释@Entity标记 Dao：包含一系列访问数据库的方法，使用注解@Dao标记 Database：数据库的持有者，作为与应用持久化相关数据的底层连接的主要接入点。使用注解@Database标记，另外需要满足以下条件：定义的类必须是一个继承于RoomDatabase的抽象类，在注解中需要定义与数据库相关联的实体类列表。包含一个没有参数的抽象方法并返回一个Dao对象 Navigation 优势 可视化的页面导航图，类似于Apple Xcode中的StoryBoard，便于我们理清页面关系。 通过destination和action完成页面间的导航。 方便添加页面切换动画。 页面间类型安全的参数传递。 通过NavigationUl，对菜单、底部导航、抽屉菜单导航进行统一的管理。 支持深层链接DeepLink。 主要元素 Navigation Graph，一种新的XML资源文件，包含应用程序所有的页面，以及页面间的关系。 NavHostFragment，一个特殊的Fragment，可以将它看作是其他Fragment的容器，Navigation Graph中的Fragment正是通过NavHostFragment进行展示的。 NavController，用于在代码中完成Navigation Graph中具体的页面切换工作。 他们三者之间的关系\n当你想切换Fragment时，使用NavController对象，告诉它你想要去Navigation Graph中的哪个Fragment，NavController会将你想去的Fragment展示NavHostFragment中。 NavigationUI 作用 Fragment的切换，除了Fragment本身的切换，通常还伴有AppBar的变化，为了方便统一管理，Navigation组件引用了NavigationUI类\n支持 AppBar ActionBar Toolbar CollapsingToolbarlayout menu 抽屉菜单（DrawLayout+Navigation View） 底部菜单（BottomNavigationView） DeepLink PendingIntent方式 当App收到某个通知推送，我们希望用户在点击该通知时，能够直接跳转到展示该通知内容的页面，可以通过Pendinglntent来完成。\nURL方式 当用户通过手机浏览器浏览网站上某个页面时，可以在网页上放置一个类似于“在应用内打开”的按钮，如果用户的手机安装有我们的App，那么通过DeepLink就能打开相应的页面；如果没有安装，那么网站可以导航到应用程序的下载页面，引导用户安装应用程序。 adb shell am start -a android.intent.action.VIEW -d “http://www.dongnaoedu.com/fromWeb\u0026quot; WorkManager 作用 后台执行不需要及时完成的任务\n特点 不需要及时完成\n发送应用程序日志、同步应用程序数据、备份用户数据等 保证任务一定会执行\nWorkManager有自己的数据库，关于任务的所有信息和数据都保存在数据库中，哪怕应用程序彻底退出，或者设备被重新启动，任务依然能够执行 兼容范围广\n最低兼容API level14 兼容方案 API23以上底层用的JobScheduler\nAPI23以下底层用的AlarmManager+Broadcast Recevers WorkManager不是一种新的线程。工作线程通常立即运行，并在任务完成后给用户反馈，而WorkManager不是即时的，不能保证任务能立即得到执行 使用方法 添加依赖 使用work类定义任务 使用WorkRequest配置任务 设置任务触发条件 将任务触发条件设置到WorkRequest 设置延时执行任务 设置指数退避策略 为任务设置tag标签 将任务提交给系统 观察任务的状态 取消任务 参数传递 周期性任务 任务链 Paging 支持的架构类型 网络数据-页面 PositionDataSource\n适用于可通过任意位置加载数据，且目标数据源数量固定的情况。例如，请求时携带的参数为start=2\u0026amp;count=5，则表示向服务端请求从第2条数据开始往后的5条数据。 PageKeyedDataSource\n适用于数据源以页的方式进行请求的情况，例如，若请求时携带的参数为page=2\u0026amp;pageSize=5，则表示数据源以5条数据为一页，当前返回第二页的5条数据。 ItemKeyedDataSource\n适用于当目标数据的下一页需要依赖于上一页数据中最后一个对象中的某个字段作为key的情况，此类分页形式常见于评论功能的实现，例如，若上一页数据中最后一个对象的key为9001，那么在请求下一页时，需要携带参数since=9001\u0026amp;pageSize=5，则服务器会返回key=9001之后的5条数据。 数据库-页面 网络数据-数据库-页面\nBoundaryCallback 三个核心类 PagedListAdatper PagedList DataSource ","description":"一个官方推出由多个库组成的套件","id":13,"section":"posts","tags":["android","jetpack"],"title":"Jetpack","uri":"https://qqnv.com/zh/posts/jetpack/"},{"content":"异常 Kotlin标准库提供了一些便利函数，使用这些内置函数，你可以拋出带自定义信息的异常，这些便利函数叫做先决条件函数，你可以用它定义先决条件，条件必须满足，目标代码才能执行。\n函数 描述 checkNotNull 如果参数为null，则抛出llegalStateException异常，否则返回非null值 require 如果参数为false，则抛出llegalArgumentException异常 requireNotNull 如果参数为null，则抛出llegalStateException异常，否则返回非null值 error 如果参数为null，则抛出llgalStateException异常并输出错误信息，否则返回非null值 assert 如果参数为false，则抛出AssertError异常，并打上断言编译器标记 1 2 3 4 5 fun check(number: Int?) { checkNotNull(number,{\u0026#34;Something is wrong\u0026#34;}) number ?: throw UnskilledException() } class UnskilledException : IllegalArgumentException(\u0026#34;操作不当\u0026#34;) 字符串操作 substring 字符串截取，substring函数支持IntRange类型（表示一个整数范围的类型）的参数，until创建的范围不包括上限值。\n1 2 3 4 5 6 7 const val NAME = \u0026#34;Jack\u0026#39;s friend.\u0026#34; fun main(){ val index = NAME.indexof(\u0026#39;\\\u0026#39;\u0026#39;) //NAME.substring(0,index) val str = NAME.substring(0 until index) println(str) } split split函数返回的是List集合数据，List集合又支持解构语法特性，它允许你在一个表达式里给多个变量赋值，解构常用来简化变量的赋值。\n1 2 3 4 5 6 7 const val NAME = \u0026#34;Jack,Rose,Merry\u0026#34; fun main(){ //val data = NAME.split(\u0026#39;,\u0026#39;) //data[0] val (origin, dest, proxy) = NAME.split(\u0026#39;,\u0026#39;) println(\u0026#34;$origin $dest $proxy\u0026#34;) } replace 字符串替换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun main(){ //字符串替换 val str = \u0026#34;The people\u0026#39;s Republic of China\u0026#34; //第一个参数是正则表达式，用来决定替换哪些字符 //第二个参数是匿名函数，用来确定该如何替换正则表达式搜索到的字符 var strs = str.replace(Regex(\u0026#34;[aeiou]\u0026#34;)) { when (it.value) { \u0026#34;a\u0026#34; -\u0026gt; \u0026#34;1\u0026#34; \u0026#34;e\u0026#34; -\u0026gt; \u0026#34;2\u0026#34; \u0026#34;i\u0026#34; -\u0026gt; \u0026#34;3\u0026#34; \u0026#34;o\u0026#34; -\u0026gt; \u0026#34;4\u0026#34; \u0026#34;u\u0026#34; -\u0026gt; \u0026#34;5\u0026#34; else -\u0026gt; it.value } } println(strs) } 字符串比较 在Kotlin中，用==检查两个字符串中的字符是否匹配，用===检查两个变量是否指向内存堆上同一对象，而在Java中==做引用比较，做结构比较时用equals方法。\n1 2 3 4 5 6 fun main(){ var str1 = \u0026#34;Jack\u0026#34; val str2 = \u0026#34;jack\u0026#34;.capitalize() println(str1 == str2) println(str1 === str2) } 遍历字符 1 2 3 4 5 fun main(){ \u0026#34;The people\u0026#39;s Republic of China\u0026#34;.forEach { print(\u0026#34;$it\u0026#34;) } } 标准库函数 apply apply函数可看作一个配置函数，你可以传入一个接收者，然后调用一系列函数来配置它以便使用，如果提供lambda给apply函数执行，它会返回配置好的接收者。\n1 2 3 4 5 6 7 8 9 10 11 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) //不用apply函数 file.setReadable(true) file.setWritable(true) file.setExecutable(false) //apply函数 file.apply { setReadable(true) setWritable(true) setExecutable(false) } let let函数能使某个变量作用于其lambda表达式里，让it关键字能引用它。let与apply比较，let会把接收者传给lambda，而apply什么都不传，匿名函数执行完，apply会返回当前接收者，而let会返回lambda的最后一行。\n1 2 3 4 5 //不用let函数 val firstElement: Int = listOf(3, 2, 1).first() val result = firstElement * firstElement //使用let函数 val results = listOf(3, 2, 1).first().let { it * it } 1 2 3 4 5 6 7 8 9 //不使用let fun formatGreeting(guestName: String?): String { return if (guestName != null) \u0026#34;Welcome $guestName.\u0026#34; else \u0026#34;What\u0026#39;s your name?\u0026#34; } //使用let fun formatGreetings(guestName: String?): String { return guestName?.let { \u0026#34;Welcome $it.\u0026#34; } ?: \u0026#34;What\u0026#39;s your name?\u0026#34; } run 光看作用域行为，run和apply差不多，但与apply不同，run函数不返回接收者，run返回的是lambda结果，可以是true或者false\n1 2 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) val result = file.run { readText().contains(\u0026#34;dream\u0026#34;) } run也能用来执行函数引用\n1 2 3 4 5 6 7 8 val result = \u0026#34;The people\u0026#39;s Republic of China\u0026#34;.run(::isLong).run(::showMessage).run(::println) fun isLong(name: String) = name.length \u0026gt; 10 fun showMessage(isLong: Boolean): String { return if (isLong) \u0026#34;Name is too long.\u0026#34; else \u0026#34;Please rename.\u0026#34; } with with函数是run的变体，他们的功能行为是一样的，但with的调用方式不同，调用with时需要值参作为其第一个参数传入。\n1 2 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) var result = with(file) { readText().contains(\u0026#34;dream\u0026#34;) } also also函数和let函数功能相似，和let一样，also也是把接收者作为值参传给lambda，但有一点不同：also返回接收者对象，而let返回lambda结果。因为这个差异，also尤其适合针对同一原始对象，利用副作用做事，既然also返回的是接收者对象，你就可以基于原始接收者对象执行额外的链式调用。\n1 2 3 4 5 //also函数 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) var fileContents: List\u0026lt;String\u0026gt; file.also { println(it.name) } .also { fileContents = it.readLines() } takeIf 和其他标准函数有点不一样，takelf函数需要判断lambda中提供的条件表达式，给出true或false结果，如果判断结果是true，从takelf函数返回接收者对象，如果是false，则返回null。如果需要判断某个条件是否满足，再决定是否可以赋值变量或执行某项任务，takelf就非常有用，概念上讲，takelf函数类似于if语句，但它的优势是可以直接在对象实例上调用，避免了临时变量赋值的麻烦。\n1 2 3 4 5 6 7 8 9 //不用takeIf函数 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) val fileContent: String? = if (file.canRead() \u0026amp;\u0026amp; file.canWrite()) file.readText() else null //takeIf函数 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) val fileContent1: String? = file .takeIf { it.exists() \u0026amp;\u0026amp; it.canRead() \u0026amp;\u0026amp; it.canWrite() } ?.readText() takeUnless takelf辅助函数takeUnless，只有判断你给定的条件结果是false时，takeUnless才会返回原始接收者对象。\n1 2 3 4 5 //takeUnless函数 val file = File(\u0026#34;/Users/qqnv/Documents/dream.txt\u0026#34;) val fileContent: String? = file .takeUnless { it.isHidden } ?.readText() List list创建与元素获取 getOrElse是一个安全索引取值函数，它需要两个参数，第一个是索引值，第二个是能提 。 供默认值的lambda表达式，如果索引值不存在的话，可用来代替异常。 getOrNull是Kotlin提供的另一个安全索引取值函数，它返回null结果，而不是抛出异常。 1 2 3 4 5 6 7 fun main(){ val list = listOf(\u0026#34;Json\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Merry\u0026#34;) //list[4] println(list.getOrElse(4) { \u0026#34;Unknown\u0026#34; }) println(list.getOrNull(4)) println(list.getOrNull(4) ?: \u0026#34;Unknown\u0026#34;) } 可变列表 在Kotlin中，支持内容修改的列表叫可变列表，要创建可变列表，可以使用mutable ListOf函数。List还支持使用toList和toMutableList函数动态实现只读列表和可变列表的相互转换。\n1 2 3 4 5 6 7 8 //可变列表 val mutableList = mutableListOf(\u0026#34;Jack\u0026#34;,\u0026#34;Rose\u0026#34;,\u0026#34;Merry\u0026#34;) mutableList.add(\u0026#34;Jane\u0026#34;) mutableList.remove(\u0026#34;Merry\u0026#34;) println(mutableList) //可变与只读列表相互转换 listOf(\u0026#34;Jack\u0026#34;,\u0026#34;Rose\u0026#34;,\u0026#34;Merry\u0026#34;).toMutableList() mutableListOf(\u0026#34;Jack\u0026#34;,\u0026#34;Rose\u0026#34;,\u0026#34;Merry\u0026#34;).toList() mutator 能修改可变列表的函数有个统一的名字：mutator函数 添加元素运算符与删除元素运算符（还记得C++中的运算符重载吗？） 基于lambda表达式指定的条件删除元素 集合遍历 for in遍历 forEach遍历 forEachIndexed遍历时要获取索引 1 2 3 4 5 //集合遍历 val list = listOf(\u0026#34;Jack\u0026#34;,\u0026#34;Rose\u0026#34;,\u0026#34;Merry\u0026#34;) for (s in list) println(s) list.forEach{ println(it)} list.forEachIndexed { index, s -\u0026gt; println(\u0026#34;$index $s\u0026#34;) } 解构 通过_符号过滤掉不想要的元素\n1 2 3 //解构 val list2 = listOf(\u0026#34;Jack\u0026#34;,\u0026#34;Rose\u0026#34;,\u0026#34;Merry\u0026#34;) val (origin,_,proxy) = list2 Set Set创建与元素获取 通过setOf 创建set集合，使用elementAt函数读取集合中的元素，其他使用方法和list类似\n1 2 3 4 val set = setOf(\u0026#34;Kotlin\u0026#34;,\u0026#34;Java\u0026#34;,\u0026#34;Scala\u0026#34;) //不能使用该方法获取set元素 //set[2] set.elementAt(2) 集合转换 把List转换成Set，去掉重复元素 快捷函数 1 2 3 4 5 //利用集合转换去除重复元素 val list = listOf(\u0026#34;Jack\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Merry\u0026#34;, \u0026#34;Merry\u0026#34;) .toSet() .toList() println(listOf(\u0026#34;Jack\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Merry\u0026#34;, \u0026#34;Merry\u0026#34;).distinct()) 数组类型 Kotlin提供各种Array，虽然是引用类型，但可以编译成Java基本数据类型\n数组类型 创建函数 IntArray intArrayOf DoubleArray doubleArrayOf LongArray longArrayOf ShortArray shortArrayOf ByteArray byteArrayOf FloatArray floatArrayOf BooleanArray booleanArrayOf Array arrayOf 1 2 3 4 //数组类型 val intArray = intArrayOf(1,2,3) listOf(1,2,3).toIntArray() arrayOf(File(\u0026#34;\u0026#34;),File(\u0026#34;\u0026#34;)) Map Map的创建 to看上去像关键字，但事实上，它是个省略了点号和参数的特殊函数，to函数将它左边和右边的值转化成一对Pair。\n1 2 mapOf(\u0026#34;Jack\u0026#34; to 20, \u0026#34;Rose\u0026#34; to 18, \u0026#34;Merry\u0026#34; to 22) mapOf(Pair(\u0026#34;Jack\u0026#34;,20), Pair(\u0026#34;Rose\u0026#34;,18)) 读取map的值 []取值运算符，读取键对应的值，如果键不存在就返回null getValue，读取键对应的值，如果键不存在就抛出异常 getOrElse，读取键对应的值，或者使用匿名函数返回默认值 getOrDefault，读取键对应的值，或者返回默认值 1 2 3 4 5 val map = mapOf(\u0026#34;Jack\u0026#34; to 20, \u0026#34;Rose\u0026#34; to 18, \u0026#34;Merry\u0026#34; to 22) println(map[\u0026#34;Jack\u0026#34;]) println(map.getValue(\u0026#34;Jane\u0026#34;)) //如果找不到会抛出异常 println(map.getOrElse(\u0026#34;Jane\u0026#34;){\u0026#34;unknown\u0026#34;}) println(map.getOrDefault(\u0026#34;Jane\u0026#34;,0)) 遍历map forEach遍历Map\n1 2 3 val map1 = mapOf(\u0026#34;Jack\u0026#34; to 20, \u0026#34;Rose\u0026#34; to 18, \u0026#34;Merry\u0026#34; to 22) map1.forEach{println(\u0026#34;${it.key}${it.value}\u0026#34;)} map1.forEach { (t, u) -\u0026gt; println(\u0026#34;$t $u\u0026#34;) } 可变集合 通过mutableMapOf创建可变的Map getOrPut键值不存在，就添加并返回结果，否则就返回已有键对应的值 1 2 3 4 5 6 7 val mutableMap = mutableMapOf(\u0026#34;Jack\u0026#34; to 20, \u0026#34;Rose\u0026#34; to 18) mutableMap += \u0026#34;Merry\u0026#34; to 24 mutableMap[\u0026#34;Merry\u0026#34;] = 24 println(mutableMap.getOrPut(\u0026#34;Merry\u0026#34;){18}) mutableMap.getOrPut(\u0026#34;Jane\u0026#34;){18} println(mutableMap) Class field 针对你定义的每一个属性，Kotlin都会产生一个field、一个getter、以及一个setter，field用来存储属性数据，你不能直接定义field，Kotlin会封装field，保护它里面的数据，只暴露给getter和setter使用。属性的getter方法决定你如何读取属性值，每个属性都有getter方法，setter方法决定你如何给属性赋值，所以只有可变属性才会有setter方法，尽管Kotlin会自动提供默认的getter和setter方法，但在需要控制如何读写属性数据时，你也可以自定义他们。\n1 2 3 4 5 6 7 var name = \u0026#34;abc\u0026#34; get() = field.capitalize() set(value) {field = value.trim()} var age = 10 get() = field.absoluteValue set(value) {field = value.absoluteValue} 计算属性 计算属性是通过一个覆盖的get或set运算符来定义，这时field就不需要了。\n1 2 val rolledValue get() = (1..6).shuffled().first() 初始化顺序 主构造函数里声明的属性 类级别的属性赋值 init初始化块里的属性赋值和函数调用 次构造函数里的属性赋值和函数调用 延迟初始化 使用lateinit关键字相当于做了一个约定在用它之前负责初始化 只要无法确认lateinit变量是否完成初始化，可以执行islnitialized检查 1 2 3 lateinit var equipment: String fun ready(){equipment = \u0026#34;Knife\u0026#34;} fun battle(){if (::equipment.isInitialized) println(equipment)} 惰性初始化 延迟初始化并不是推后初始化的唯一方式，你也可以暂时不初始化某个变量，直到首次使用它，这个叫作惰性初始化。\n1 2 3 4 5 6 7 8 class Player(name_: String){ var name = name_ val config by lazy { loadConfig() } private fun loadConfig(): String { println(\u0026#34;loading...\u0026#34;) return \u0026#34;xxx\u0026#34; } } Object object关键字 使用object关键字，你可以定义一个只能产生一个实例的类-单例 使用object关键字有三种方式 对象声明 对象表达式 伴生对象 对象声明 对象声明有利于组织代码和管理状态，尤其是管理整个应用运行生命周期内的某些一致性状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 object ApplicationConfig{ init { println(\u0026#34;ApplicationConfig\u0026#34;) } fun doSomething(){ println(\u0026#34;doSomething\u0026#34;) } } fun main() { //类名，实例名 ApplicationConfig.doSomething() //打印多次会是同一个实例 prinlin(ApplicationConfig) prinlin(ApplicationConfig) } 对象表达式 有时候你不一定非要定义一个新的命名类不可，也许你需要某个现有类的一种变体实例，但只需用一次就行了，事实上，，对于这种用完就丢的类实例，连命名都可以省了。这个对象表达式是XX的子类，这个匿名类依然遵循object关键字的一个规则，即一旦实例化，该匿名类只能有唯一个实例存在。\n1 2 3 4 5 6 7 8 open class Player{ open fun load() = \u0026#34;loading...\u0026#34; } fun main(){ val p = object: Player(){ override fun load() = \u0026#34;anonymous loading...\u0026#34; } } 伴生对象 如果你想将某个对象的初始化和一个类实例捆绑在一起，可以考虑使用伴生对象，使用companion修饰符，你可以在一个类定义里声明一个伴生对象，一个类里只能有一个伴生对象。\n1 2 3 4 5 6 7 8 9 10 11 open class ConfigMap { companion object { private const val PATH = \u0026#34;xxx\u0026#34; fun load() = File(PATH).readBytes() } } fun main() { //static ConfigMap.load() } 嵌套类 如果一个类只对另一个类有用，那么将其嵌入到该类中并使这两个类保持在一起是合乎逻辑的，可以使用嵌套类。\n1 2 3 4 5 6 7 8 9 10 class Player2 { class Equipment(var name: String) { fun show() = println(\u0026#34;equipment: $name\u0026#34;) } fun battle(){} } fun main() { Player2.Equipment(\u0026#34;knife\u0026#34;).show() } 数据类 数据类，是专门设计用来存储数据的类 数据类提供了toString的个性化实现 ==符号默认情况下，比较对象就是比较它们的引用值，数据类提供了equals和hash Code的个性化实现 数据类支持解构语法 1 2 3 4 5 6 7 8 data class Coordinate(var x: Int, var y: Int) { val isInBounds = x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 } fun main() { //数据类重写了equel方法，所以返回true println(Coordinate(10,20) == Coordinate(10,20)) } 使用数据类的条件 正是因为上述这些特性，你才倾向于用数据类来表示存储数据的简单对象，对于那些经常需要比较、复制或打印自身内容的类，数据类尤其适合它们。然而，一个类要成为数据类，也要符合一定条件。总结下来，主要有三个方面：\n数据类必须有至少带一个参数的主构造函数 数据类主构造函数的参数必须是val或var 数据类不能使用abstract、open、sealed和inner修饰符 copy 除了重写Any类的部分函数，提供更好用的默认实现外，数据类还提供了一个函数，它可以用来方便地复制一个对象。假设你想创建一个Student实例，除了name属性，它拥有和另一个现有Student实例完全一样的属性值，如果Student是个数据类，那么复制现有Student实例就很简单了，只要调用copy函数，给想修改的属性传入值参就可以了。\n解构声明 解构声明的后台实现就是声明component1、component2等若干个组件函数，让每个函数负责管理你想返回的一个属性数据，如果你定义一个数据类，它会自动为所有定义在主构造函数的属性添加对应的组件函数\n1 2 3 4 5 6 7 8 9 class PlayerScore (val experience: Int,val level: Int){ operator fun component1() = experience operator fun component2() = level } fun main() { val (x,y) = PlayerScore(10,20) println(\u0026#34;$x $y\u0026#34;) } 运算符重载 如果要将内置运算符应用在自定义类身上，你必须重写运算符函数，告诉编译器该如何操作自定义类。\n1 2 3 4 5 6 7 8 9 data class Coordinate2(var x: Int, var y: Int) { operator fun plus(other: Coordinate2) = Coordinate2(x + other.x, y + other.y) } fun main() { val c1 = Coordinate2(10, 20) val c2 = Coordinate2(10, 20) println(c1 + c2) } 枚举类 用来定义常量集合的一种特殊类 枚举类可以定义一个函数 密封类 对于更复杂的ADT，你可以使用Kotlin的密封类（sealed class）来实现更复杂的定义，密封类可以用来定义一个类似于枚举类的ADT，但你可以更灵活地控制某个子类型。 密封类可以有若干个子类，要继承密封类，这些子类必须和它定义在同一个文件里。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sealed class LicenseStatus2 { object UnQualified : LicenseStatus2() object Learning : LicenseStatus2() class Qualified(val licenseId: String) : LicenseStatus2() } class Driver2(var status: LicenseStatus2){ fun checkLicense(): String{ return when(status) { is LicenseStatus2.UnQualified -\u0026gt; \u0026#34;没资格\u0026#34; is LicenseStatus2.Learning -\u0026gt; \u0026#34;在学\u0026#34; is LicenseStatus2.Qualified -\u0026gt; \u0026#34;有资格，驾驶证编号：${(this.status as LicenseStatus2.Qualified).licenseId}\u0026#34; } } } fun main() { val status = LicenseStatus2.Qualified(\u0026#34;99999\u0026#34;) val driver = Driver2(status).checkLicense() println(driver) } Interface Interface定义 Kotlin规定所有的接口属性和函数实现都要使用override关键字，接口中定义的函数并不需要open关键字修饰，他们默认就是open的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface Movable { var maxSpeed: Int var wheels: Int fun move(movable: Movable): String } class Car(_name: String, override var wheels: Int = 4): Movable{ override var maxSpeed: Int get() = TODO(\u0026#34;Not yet implemented\u0026#34;) set(value) {} override fun move(movable: Movable): String { TODO(\u0026#34;Not yet implemented\u0026#34;) } } 默认实现 只要你愿意，你可以在接口里提供默认属性的getter方法和函数实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Movable { val maxSpeed: Int get() = (0..4).shuffled().last() var wheels: Int fun move(movable: Movable): String } class Car(_name: String, override var wheels: Int = 4): Movable{ override var maxSpeed: Int get() = super.maxSpeed set(value) {} override fun move(movable: Movable): String { TODO(\u0026#34;Not yet implemented\u0026#34;) } } 抽象类 定义 要定义一个抽象类，你需要在定义之前加上abstract关键字，除了具体的函数实现，抽象类也可以包含抽象函数一只有定义，没有函数实现。\n泛型类 泛型类的构造函数可以接受任何类型。\nMagicBox类指定的泛型参数由放在一对\u0026lt;\u0026gt;里的字母T表示，T是个代表item类型的占位符。MagicBox类接受任何类型的item作为主构造函数值（item：T），并将item值赋给同样是T类型的subject私有属性。\n1 2 3 4 5 6 7 8 9 10 11 12 class MagicBox\u0026lt;T\u0026gt;(item: T) { private var subject: T = item } class Boy(val name: String, val age: Int) class Dog(val weight: Int) fun main() { val box1: MagicBox\u0026lt;Boy\u0026gt; = MagicBox(Boy(\u0026#34;Jack\u0026#34;,18)) val box2: MagicBox\u0026lt;Dog\u0026gt; = MagicBox(Dog(20)) } 函数 泛型函数 泛型参数也可以用于函数。 定义一个函数用于获取元素，当且仅当MagicBox可用时，才能获取元素。 多泛型参数 泛型函数或泛型类也可以有多个泛型参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package kot.inter /** * 泛型类及泛型约束 */ class MagicBox\u0026lt;T : Human\u0026gt;(item: T) { var available = false private var subject: T = item fun fetch(): T? { return subject.takeIf { available } } fun \u0026lt;R\u0026gt; fetch(subjectModFunction: (T) -\u0026gt; R): R? { return subjectModFunction(subject).takeIf { available } } //运算符重载 operator fun get(index: Int): T? = subject[index]?.takeIf { available } } open class Human(val age: Int) class Boy(val name: String, age: Int) : Human(age) class Man(val name: String, val age: Int) class Dog(val weight: Int) fun main() { val box1: MagicBox\u0026lt;Boy\u0026gt; = MagicBox(Boy(\u0026#34;Jack\u0026#34;, 18)) // val box2: MagicBox\u0026lt;Dog\u0026gt; = MagicBox(Dog(20)) box1.available = true box1.fetch()?.run { println(\u0026#34;you find $name\u0026#34;) } val man = box1.fetch() { Man(it.name, it.age.plus(10)) } //运算符重载后取值 box1[1] } out out（协变），如果泛型类只将泛型类型作为函数的返回（输出），那么使用out，可以称之为生产类/接口，因为它主要是用来生产（produce）指定的泛型对象。\n1 2 3 interface Production\u0026lt;out T\u0026gt; { fun product(): T } in in（逆变），如果泛型类只将泛型类型作为函数的入参（输入），那么使用in，可以称之为消费者类/接口，因为它主要是用来消费（consume）指定的泛型对象。\n1 2 3 interface Consumer\u0026lt;in T\u0026gt; { fun consumer(item: T) } invariant invariant（不变），如果泛型类既将泛型类型作为函数参数，又将泛型类型作为函数的输出，那么既不用out也不用in。\n1 2 3 4 interface ProductionConsumer\u0026lt;T\u0026gt; { fun product(): T fun consumer(item: T) } 父类泛型对象可以赋值给子类对象，用in\n子类泛型对象可以赋值给父类对象，用out\nreified 有时候，你可能想知道某个泛型参数具体是什么类型，reified关键字能帮你检查泛型参数类型。Kotlin不允许对泛型参数T做类型检查，因为泛型参数类型会被类型擦除，也就是说，T的类型信息在运行时是不可知的，Java也有这样的规则。\n定义扩展函数 扩展可以在不直接修改类定义的情况下增加类功能，扩展可以用于自定义类，也可以用于比如List、String，以及Kotlin标准库里的其他类。和继承相似，扩展也能共享类行为，在你无法接触某个类定义，或者某个类没有使用open修饰符，导致你无法继承它时，扩展就是增加类功能的最好选择。\n1 2 3 4 5 6 7 fun String.addExt(amount: Int = 1) = this + \u0026#34;!\u0026#34;.repeat(amount) fun Any.easyPrint() = println(this) fun main() { println(\u0026#34;abc\u0026#34;.addExt(2)) \u0026#34;abc\u0026#34;.easyPrint() } 泛型扩展函数 新的泛型扩展函数不仅可以支持任何类型的接收者，还保留了接收者的类型信息使用泛型类型后，扩展函数能够支持更多类型的接收者，适用范围更广了。\n1 2 3 4 5 6 7 8 9 10 fun String.addExt(amount: Int = 1) = this + \u0026#34;!\u0026#34;.repeat(amount) fun \u0026lt;T\u0026gt; T.easyPrint(): T { println(this) return this } fun main() { \u0026#34;abc\u0026#34;.easyPrint().addExt(2).easyPrint() } 扩展属性 除了给类添加功能扩展函数外，你还可以给类定义扩展属性，给String类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。\n1 2 3 4 5 6 7 8 9 10 11 val String.numVowels get() = count { \u0026#34;aeiou\u0026#34;.contains(it) } fun \u0026lt;T\u0026gt; T.easyPrint(): T { println(this) return this } fun main() { \u0026#34;The people\u0026#39;s Republic of China.\u0026#34;.numVowels.easyPrint() } 可空类扩展 你也可以定义扩展函数用于可空类型，在可空类型上定义扩展函数，你就可以直接在扩展函数体内解决可能出现的空值问题。\n1 2 3 4 5 6 fun String?.printWithDefault(default: String) = print(this ?: default) fun main() { val nullableString: String? = null nullableString.printWithDefault(\u0026#34;abc\u0026#34;) } infix关键字 infix关键字适用于有单个参数的扩展和类函数，可以让你以更简洁的语法调用函数，如果一个函数定义使用了infix关键字，那么调用它时，接收者和函数之间的点操作以及参数的一对括号都可以不要。\n1 2 3 4 5 6 infix fun String?.printWithDefault(default: String) = print(this ?: default) fun main() { val nullableString: String? = null nullableString printWithDefault \u0026#34;abc\u0026#34; } 定义扩展文件 扩展函数需要在多个文件里使用，可以将它定义成单独的文件，然后import\n1 2 3 package kot.func fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.randomTake(): T = this.shuffled().first() 1 2 3 4 5 6 7 import kot.func.randomTake fun main(){ val list = listof(\u0026#34;Jason\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Tom\u0026#34;) val set = setof(\u0026#34;love\u0026#34;,\u0026#34;hate\u0026#34;,\u0026#34;like\u0026#34;) list.randomTake() } 重命名扩展 有时候，你想使用一个扩展或一个类，但它的名字不和你的意。可使用“as”\n1 2 3 4 5 6 7 import kot.func.randomTake as randomer fun main(){ val list = listof(\u0026#34;Jason\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Tom\u0026#34;) val set = setof(\u0026#34;love\u0026#34;,\u0026#34;hate\u0026#34;,\u0026#34;like\u0026#34;) list.randomer() } Kotlin标准库中的扩展 Kotlin标准库提供的很多功能都是通过扩展函数和扩展属性来实现的，包含类扩展的标准库文件通常都是以类名加s后缀来命名的，例如Sequences.kt，Ranges.kt，Maps.kt。\nDSL 带接收者的函数字面量 apply函数是如何做到支持接收者对象的隐式调用的\n1 2 3 4 public inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { block() return this } DSL 使用这样的编程范式，就可以写出业界知名的“领域特定语言”(DSL) ，一种API编程范式，暴露接收者的函数和特性，以便于使用你定义的lambda表达式来读取和配置它们。\n变换 函数式编程 我们一直在学习面向对象编程范式，另一个较知名的编程范式是诞生于20世纪50年，基于抽象数学的入演算发展而来的函数式编程，尽管函数式编程语言更常用在学术而非商业软件领域，但它的一些原则适用于任何编程语言。函数式编程范式主要依赖于高阶函数（以函数为参数或返回函数）返回的数据，这些高阶函数专用于处理各种集合，可方便地联合多个同类函数构建链式操作以创建复杂的计算行为。Kotlin支持多种编程范式，所以你可以混用面向对象编程和函数式编程范式来解决手头的问题。\n乍看之下，实现同样的任务，Java版本和函数式版本的代码量差不多，但仔细分析一下，就能看出函数式版本的诸多优势。\n累加变量（employeeShirtSizes）都是隐式定义的。 函数运算结果会自动赋值给累加变量，降低了代码出错的机会。 执行新任务的函数很容易添加到函数调用链上，因为他们都兼容Iterable类型。 函数类别 一个函数式应用通常由三大类函数构成：变换transform、过滤filter、合并combine。每类函数都针对集合数据类型设计，目标是产生一个最终结果。函数式编程用到的函数生来都是可组合的，也就是说，你可以组合多个简单函数来构建复杂的计算行为。\n变换 变换是函数式编程的第一大类函数，变换函数会遍历集合内容，用一个以值参形式传入的变换器函数，变换每一个元素，然后返回包含已修改元素的集合给链上的其他函数。\n最常用的两个变换函数是map和flatMap。\nmap map变换函数会遍历接收者集合，让变换器函数作用于集合里的各个元素，返回结果是包含已修改元素的集合，会作为链上下一个函数的输入。 可以看到，原始集合没有被修改，map变换函数和你定义的变换器函数做完事情后，返回的是一个新集合，这样，变量就不用变来变去了。 事实上，函数式编程范式支持的设计理念就是不可变数据的副本在链上的函数间传递。 map返回的集合中的元素个数和输入集合必须一样，不过返回的新集合里的元素是不同类型的。 flatmap flatMap函数操作一个集合的集合，将其中多个集合中的元素合并后返回一个包含所有元素的单一集合。\n过滤 过滤是函数式编程的第二大类函数，过滤函数接受一个predicate函数，用它按给定条件检查接收者集合里的元素并给出true或false的判定。如果predicate函数返回true，受检元素就会添加到过滤函数返回的新集合里。如果predicate函数返回false，那么受检元素就被移出新集合。 filter过滤函数接受一个predicate函数，在flatMap遍历它的输入集合中的所有元素时，filter函数会让predicate函数按过滤条件，将符合条件的元素都放入它返回的新集合里。最后，flatMap会把变换器函数返回的子集合合并在一个新集合里。 1 2 3 4 5 6 7 8 //变换过滤集合 val items = listOf( listOf(\u0026#34;red apple\u0026#34;, \u0026#34;green apple\u0026#34;, \u0026#34;blue apple\u0026#34;), listOf(\u0026#34;red fish\u0026#34;, \u0026#34;blue fish\u0026#34;), listOf(\u0026#34;yellow banana\u0026#34;, \u0026#34;teal banana\u0026#34;) ) items.flatMap { it.filter { it.contains(\u0026#34;red\u0026#34;) } }.easyPrint() filter 找素数，除了1和它本身，不能被任何数整除的数。仅使用了几个简单函数，我们就解决了找素数这个比较复杂的问题，这就是函数式编程的独特魅力：每个函数做一点，组合起来就能干大事。\n1 2 3 4 5 6 7 //组合使用找素数,除了1和它本身，不能被任何数整除的数 val numbers = listOf(7, 4, 8, 4, 3, 22, 18, 11) numbers.filter { numbers -\u0026gt; (2 until numbers) .map { numbers % it } .none { it == 0 } }.easyPrint() 合并 合并是函数式编程的第三大类函数，合并函数能将不同的集合合并成一个新集合，这个接收者是包含集合的集合的flatMap函数不同。\nzip zip合并函数来合并两个集合，返回一个包含键值对的新集合。\n1 2 3 4 5 //zip合并集合 val employees = listOf(\u0026#34;Jack\u0026#34;, \u0026#34;Jason\u0026#34;, \u0026#34;Tommy\u0026#34;) val age = listOf(18, 20, 16) val employeesAge = employees.zip(age).toMap() employeesAge[\u0026#34;Jack\u0026#34;].easyPrint() fold 另一个可以用来合并值的合并类函数是fold，这个合并函数接受一个初始累加器值，随后会根据匿名函数的结果更新。\n1 2 3 4 //fold合并函数，将每个元素*3然后累加 listOf(1, 2, 3, 4).fold(0) { accumulator, number -\u0026gt; accumulator + number * 3 }.easyPrint() 序列 List、 Set、Map集合类型，这几个集合类型统称为及早集合（eager collection） 这些集合的任何一个实例在创建后，它要包含的元素都会被加入并允许你访问。对应及早集合，Kotlin还有另外一类集合：惰性集合（lazy collection）类似于类的惰性初始化，惰性集合类型的性能表现优异，尤其是用于包含大量元素的集合时，因为集合元素是按需产生的。 Kotlin有个内置惰性集合类型叫序列（Sequence） ，序列不会索引排序它的内容，也不记录元素数目，事实上，在使用一个序列时，序列里的值可能有无限多，因为某个数据源能产生无限多个元素。 针对某个序列，你可能会定义一个只要序列有新值产生就被调用一下的函数，这样的函数叫迭代器函数，要定义一个序列和它的迭代器，你可以使用Kotlin的序列构造函数generateSequence，generateSequence函数接受一个初始种子值作为序列的起步值，在用generateSequence定义的序列上调用一个函数时，generateSequence函数会调用你指定的迭代器函数，决定下一个要产生的值。 注解 JvmName\n@file:JvmName(“”)-\u0026gt;给kotlin文件加该注解，在Java中访问里面的属性 JvmField\n@JvmField-\u0026gt;给kotlin中类的参数加该注解，在Java中无需get方法访问\n以静态方式提供伴生对象里定义的值 JvmOverloads\n@JvmField-\u0026gt;设计一个可能会暴露给Java用户的API，使用该注解，强制重载 JvmStatic\n@JvmStatic-\u0026gt;类似于Jv mField，允许直接调用伴生对象里的函数 ","description":"Android新的官方开发语言","id":14,"section":"posts","tags":["kotlin","android"],"title":"Kotlin","uri":"https://qqnv.com/zh/posts/kotlin%E5%9F%BA%E7%A1%80/"},{"content":"as运行main（）方法 报错：SourceSet with name ‘main’ not found\n解决：在项目的.idea/gradle.xml中的添加\u0026lt;option name=\u0026quot;delegatedBuild\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt;\n原因：不委托gradle进行构建，就是让jvm执行Java类的main方法，而不是让gradle当作task来执行\nGradle配置 阿里代理 最近由于更新了AndroidStudio所以相应的Gradle要更新下载\n关于Gradle下载推荐使用联通或电信网络，不要用移动网络\nGradle下载成功后便可以通过阿里云镜像源下载其他的jar包和相关插件\n1.在本地.gradle文件夹下新建一个init.gradle的文件，内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 allprojects{ repositories { def ALIYUN_REPOSITORY_URL = \u0026#39;http://maven.aliyun.com/nexus/content/groups/public\u0026#39; def ALIYUN_JCENTER_URL = \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39; all { ArtifactRepository repo -\u0026gt; if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith(\u0026#39;https://repo1.maven.org/maven2\u0026#39;)) { project.logger.lifecycle \u0026#34;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.\u0026#34; remove repo } if (url.startsWith(\u0026#39;https://jcenter.bintray.com/\u0026#39;)) { project.logger.lifecycle \u0026#34;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.\u0026#34; remove repo } } } maven { url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL } } } 在Android项目build.gradle文件的buildscript中repositories内和allprojects中repositories内添加如下代码：\n1 2 3 4 maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public/\u0026#39; } maven { url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39; } maven { url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/google\u0026#39; } maven { url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin\u0026#39; } 重新build项目\n手动配置Gradle及插件版本 gradle版本及插件对应版本：https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin gradle国内下载网址：https://services.gradle.org/distributions/ gradle官网下载地址：https://gradle.org/releases/ ","description":"Android Studio工具的使用及配置","id":15,"section":"posts","tags":["android"],"title":"AndroidStudio","uri":"https://qqnv.com/zh/posts/androidstudio/"},{"content":"Ubuntu安装 下载镜像文件 下载runfuns启动盘制作文件 制作启动U盘\n打开软件，引导类型选择下载好的镜像文件，其余默认，然后开始制作启动盘 重启电脑，进入BIOS，选择U盘，然后选择Ubantu即可安装 Ubuntu笔记本设置合盖不休眠 打开终端：sudo vim /etc/systemd/logind.conf 修改#HandleLidSwitch=suspend为HandleLidSwitch=ignore 重启服务器或系统 Java环境变量配置 前往Oracle官网下载jdk压缩包，解压安装包\ncontrol+alt+T打开命令行，然后sudo mkdir /usr/local/java创建目标目录\n命令行输入sudo cp -r+“空格”+你要复制的文件的原目录/你要复制的文件+“空格”+目标目录\n命令行输入sudo gedit /etc/environment修改PATH在文末添加：\n1 2 export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/usr/local/java/jdk1.8.0_311 命令行输入source /etc/environment使环境变量生效\n防止重启后，配置的环境变量无效，配置系统变量\n命令行输入sudo gedit /etc/profile打开文件后在文末添加：\n#set Java environment export JAVA_HOME=/usr/local/java/jdk1.8.0_311 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 命令行输入source /etc/profile使环境变量生效\n命令行输入sudo shutdown -r now输入电脑密码重启\n重启后命令行输入java -version，若出现ubantu bash:/usr/local/java/jdk1.8.0_311/bin/java: 没有那个文件或目录的提示则命令行输入sudo apt-get install libc6-i386下载编译时环境\n最后命令行输入java -version成功显示jdk版本信息\nprofile文件若被误删或误改，可强制使用rm -f 文件名删除该文件\n然后sudo cp /usr/share/base-files/profile /etc/profile复原profile\nUbuntu常用命令 创建文件：touch a.txt 创建文件夹：mkdir newfolder 删除文件：rm a.txt 删除文件夹：rmdir newfolder 删除文件夹及文件夹内所有文件：rm -rf newfolder 切换到root用户：su root 切换到普通用户：su xyx nginx安装：sudo apt-get install nginx nginx启动：sudo /etc/init.d/nginx start ","description":"Linux桌面系统","id":16,"section":"posts","tags":["ubuntu","linux"],"title":"安装Ubuntu教程","uri":"https://qqnv.com/zh/posts/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%B9%8Bubuntu/"},{"content":"Typecho搭建博客 登录宝塔面板 前往Typecho官网下载Typecho 安装包 安装Nginx、MySQL、PHP等运行时环境 创建站点，进入站点根目录，将Typecho解压后的内容上传到根目录下（删除build文件夹） 浏览器打开站点，按照提示安装Typecho handsome主题及魔改 购买主题 访问handsome博客消费88元购买主题 访问handsome主题教程即可安装使用 crisp客服 到crisp官网注册 注册完成后，点击 设置-网站设置-显示整合-HTML，复制代码添加至后台主题设置 自定义输出head 头部的HTML代码即可 首页新年倒计时 将以下代码添加至设置外观-开发者设置-首页列表最前方广告位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /*首页倒计时*/ \u0026lt;style\u0026gt; .gn_box{ border: none; border-radius: 15px; } .gn_box { padding: 10px 14px; margin: 10px; margin-bottom: 20px; text-align: center; background-color: #fff; } #t_d{ color: #982585; font-size: 18px; } #t_h{ color: #8f79c1; font-size: 18px; } #t_m{ color: #65b4b5; font-size: 18px; } #t_s{ color: #83caa3; font-size: 18px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;gn_box\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;font color=#E80017\u0026gt;2\u0026lt;/font\u0026gt;\u0026lt;font color=#D1002E\u0026gt;0\u0026lt;/font\u0026gt;\u0026lt;font color=#BA0045\u0026gt;2\u0026lt;/font\u0026gt;\u0026lt;font color=#A3005C\u0026gt;1\u0026lt;/font\u0026gt;\u0026lt;font color=#8C0073\u0026gt;年\u0026lt;/font\u0026gt;\u0026lt;font color=#75008A\u0026gt;-\u0026lt;/font\u0026gt; \u0026lt;font color=#5E00A1\u0026gt;新\u0026lt;/font\u0026gt;\u0026lt;font color=#4700B8\u0026gt;年\u0026lt;/font\u0026gt;\u0026lt;font color=#3000CF\u0026gt;倒\u0026lt;/font\u0026gt;\u0026lt;font color=#1900E6\u0026gt;计\u0026lt;/font\u0026gt;\u0026lt;font color=#0200FD\u0026gt;时\u0026lt;/font\u0026gt;\u0026lt;/h1\u0026gt;\u0026lt;center\u0026gt; \u0026lt;div id=\u0026#34;CountMsg\u0026#34; class=\u0026#34;HotDate\u0026#34;\u0026gt;\u0026lt;span id=\u0026#34;t_d\u0026#34;\u0026gt; 天\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026#34;t_h\u0026#34;\u0026gt; 时\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026#34;t_m\u0026#34;\u0026gt; 分\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026#34;t_s\u0026#34;\u0026gt; 秒\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function getRTime() { var EndTime = new Date(\u0026#39;2021/01/01 00:00:00\u0026#39;); var NowTime = new Date(); var t = EndTime.getTime() - NowTime.getTime(); var d = Math.floor(t / 1000 / 60 / 60 / 24); var h = Math.floor(t / 1000 / 60 / 60 % 24); var m = Math.floor(t / 1000 / 60 % 60); var s = Math.floor(t / 1000 % 60); var day = document.getElementById(\u0026#34;t_d\u0026#34;); if (day != null) { day.innerHTML = d + \u0026#34; 天\u0026#34;; } var hour = document.getElementById(\u0026#34;t_h\u0026#34;); if (hour != null) { hour.innerHTML = h + \u0026#34; 时\u0026#34;; } var min = document.getElementById(\u0026#34;t_m\u0026#34;); if (min != null) { min.innerHTML = m + \u0026#34; 分\u0026#34;; } var sec = document.getElementById(\u0026#34;t_s\u0026#34;); if (sec != null) { sec.innerHTML = s + \u0026#34; 秒\u0026#34;; } } setInterval(getRTime, 1000); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 彩色标签云 设置外观-开发者设置-自定义JavaScript中添加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let tags = document.querySelectorAll(\u0026#34;#tag_cloud-2 a\u0026#34;); let infos = document.querySelectorAll(\u0026#34;.badge\u0026#34;); let colorArr = [\u0026#34;#428BCA\u0026#34;, \u0026#34;#AEDCAE\u0026#34;, \u0026#34;#ECA9A7\u0026#34;, \u0026#34;#DA99FF\u0026#34;, \u0026#34;#FFB380\u0026#34;, \u0026#34;#D9B999\u0026#34;]; tags.forEach(tag =\u0026gt; { tagsColor = colorArr[Math.floor(Math.random() * colorArr.length)]; tag.style.backgroundColor = tagsColor; }); infos.forEach(info =\u0026gt; { infosColor = colorArr[Math.floor(Math.random() * colorArr.length)]; info.style.backgroundColor = infosColor; }); function addNumber(a) { var length = document.getElementById(\u0026#34;comment\u0026#34;).value.length; if(length\u0026gt; 0){ document.getElementById(\u0026#34;comment\u0026#34;).focus() document.getElementById(\u0026#34;comment\u0026#34;).value += \u0026#39;\\n\u0026#39; + a + new Date }else{ document.getElementById(\u0026#34;comment\u0026#34;).focus() document.getElementById(\u0026#34;comment\u0026#34;).value += a + new Date } } 设置外观-PJAX-PJAX回调函数中添加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let tags = document.querySelectorAll(\u0026#34;#tag_cloud-2 a\u0026#34;); let infos = document.querySelectorAll(\u0026#34;.badge\u0026#34;); let colorArr = [\u0026#34;#428BCA\u0026#34;, \u0026#34;#AEDCAE\u0026#34;, \u0026#34;#ECA9A7\u0026#34;, \u0026#34;#DA99FF\u0026#34;, \u0026#34;#FFB380\u0026#34;, \u0026#34;#D9B999\u0026#34;]; tags.forEach(tag =\u0026gt; { tagsColor = colorArr[Math.floor(Math.random() * colorArr.length)]; tag.style.backgroundColor = tagsColor; }); infos.forEach(info =\u0026gt; { infosColor = colorArr[Math.floor(Math.random() * colorArr.length)]; info.style.backgroundColor = infosColor; }); function addNumber(a) { var length = document.getElementById(\u0026#34;comment\u0026#34;).value.length; if(length\u0026gt; 0){ document.getElementById(\u0026#34;comment\u0026#34;).focus() document.getElementById(\u0026#34;comment\u0026#34;).value += \u0026#39;\\n\u0026#39; + a + new Date }else{ document.getElementById(\u0026#34;comment\u0026#34;).focus() document.getElementById(\u0026#34;comment\u0026#34;).value += a + new Date } } 首页文章版式圆角化 项修改的是首页文章版式，包括图片使其四个角由方形变成圆角形状。将以下代码添加至后台主题设置- 自定义CSS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /*首页文章版式圆角化,圆角大小可修改15px数值*/ .panel{ border: none; border-radius: 15px; } .panel-small{ border: none; border-radius: 15px; } .item-thumb{ border-radius: 15px; } 首页文章图片获取焦点放大 本项修改的是首页文章图片，将鼠标放到首页头图后使其放大。将以下代码添加至后台主题设置-自定义CSS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /*首页文章图片获取焦点放大,放大的时间和大小自行修改以下数值*/ .item-thumb{ cursor: pointer; transition: all 0.6s; } .item-thumb:hover{ transform: scale(1.05); } .item-thumb-small{ cursor: pointer; transition: all 0.6s; } .item-thumb-small:hover{ transform: scale(1.05); } 文章标题居中 本项修改的是文章标题，使其居中。将以下代码添加至后台主题设置-自定义CSS\n1 2 3 4 5 6 7 /*文章标题居中*/ .panel h2{ text-align: center; } .post-item-foot-icon{ text-align: center; } 首页文章版式阴影化 本项修改的是文章版式阴影化。将以下代码添加至后台主题设置-自定义CSS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /*panel阴影,阴影颜色修改rgba后面的值*/ .panel{ box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); -moz-box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); } .panel:hover{ box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); -moz-box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); } .panel-small{ box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); -moz-box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); } .panel-small:hover{ box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); -moz-box-shadow: 1px 1px 5px 5px rgba(255, 112, 173, 0.35); } /*如果也想使盒子四周也有阴影，加上以下代码*/ .app.container { box-shadow: 0 0 30px rgba(255, 112, 173, 0.35); } mac代码高亮插件 详细教程请到Xcnte’s Blog查看\n此外，按教程修改后可能会出现行号遮住代码且和代码不齐问题，可能是cdn或浏览器缓存引起的，可尝试清理浏览器缓存\n显示评论者的信息 详细教程请到松鼠的博客查看\n响应耗时访客总数全站字数 宝塔面板进入目录**/usr/themes/handsome/libs/Content.php**，将下面代码复制到class Content{}之前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /*访问总量*/ function theAllViews(){ $db = Typecho_Db::get(); $row = $db-\u0026gt;fetchAll(\u0026#39;SELECT SUM(VIEWS) FROM `typecho_contents`\u0026#39;); echo number_format($row[0][\u0026#39;SUM(VIEWS)\u0026#39;]); } /*响应时间*/ function timer_start() { global $timestart; $mtime = explode( \u0026#39; \u0026#39;, microtime() ); $timestart = $mtime[1] + $mtime[0]; return true; } timer_start(); function timer_stop( $display = 0, $precision = 3 ) { global $timestart, $timeend; $mtime = explode( \u0026#39; \u0026#39;, microtime() ); $timeend = $mtime[1] + $mtime[0]; $timetotal = number_format( $timeend - $timestart, $precision ); $r = $timetotal \u0026lt; 1 ? $timetotal * 1000 . \u0026#34; ms\u0026#34; : $timetotal . \u0026#34; s\u0026#34;; if ( $display ) { echo $r; } return $r; } 在**/usr/themes/handsome/component/sidebar.php**的开头加入下面的代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php //字数统计 function allOfCharacters() { $chars = 0; $db = Typecho_Db::get(); $select = $db -\u0026gt;select(\u0026#39;text\u0026#39;)-\u0026gt;from(\u0026#39;table.contents\u0026#39;); $rows = $db-\u0026gt;fetchAll($select); foreach ($rows as $row) { $chars += mb_strlen(trim($row[\u0026#39;text\u0026#39;]), \u0026#39;UTF-8\u0026#39;); } $unit = \u0026#39;\u0026#39;; if($chars \u0026gt;= 10000) { $chars /= 10000; $unit = \u0026#39;万\u0026#39;; } else if($chars \u0026gt;= 1000) { $chars /= 1000; $unit = \u0026#39;千\u0026#39;; } $out = sprintf(\u0026#39;%.2lf %s\u0026#39;,$chars, $unit); return $out; } ?\u0026gt; 在**/usr/themes/handsome/component/sidebar.php**，找到博客信息下面添加以下代码 1 2 3 4 5 6 7 8 9 \u0026lt;li class=\u0026#34;list-group-item text-second\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;blog-info-icons\u0026#34;\u0026gt; \u0026lt;i data-feather=\u0026#34;users\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;badge pull-right\u0026#34;\u0026gt;\u0026lt;?php echo theAllViews();?\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;?php _me(\u0026#34;访客总数\u0026#34;) ?\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;list-group-item text-second\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;blog-info-icons\u0026#34;\u0026gt; \u0026lt;i data-feather=\u0026#34;refresh-ccw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;badge pull-right\u0026#34;\u0026gt;\u0026lt;?php echo timer_stop();?\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;?php _me(\u0026#34;响应耗时\u0026#34;) ?\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;list-group-item text-second\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;blog-info-icons\u0026#34;\u0026gt;\u0026lt;i data-feather=\u0026#34;edit-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;badge pull-right\u0026#34;\u0026gt;\u0026lt;?php echo allOfCharacters(); ?\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;?php _me(\u0026#34;全站字数\u0026#34;) ?\u0026gt;\u0026lt;/li\u0026gt; 全站友链显示小图 在**/usr/themes/handsome/component/aside.php**里面大约209行的地方替换代码\n1 2 3 4 \u0026lt;!--使用links插件，输出全站友链--\u0026gt; \u0026lt;?php $mypattern1 = \u0026#34;\u0026lt;li data-original-title=\\\u0026#34;{title}\\\u0026#34; data-toggle=\\\u0026#34;tooltip\\\u0026#34; data-placement=\\\u0026#34;top\\\u0026#34;\u0026gt;\u0026lt;a rel=\u0026#39;noopener\u0026#39; href=\\\u0026#34;{url}\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;\u0026lt;img style=\\\u0026#34;width:18px;height:18px;border-radius:50%;margin-right:3px;\\\u0026#34; src=\\\u0026#34;{image}\\\u0026#34; /\u0026gt;\u0026lt;span\u0026gt;{name}\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#34;; Handsome_Plugin::output($mypattern1, 0, \u0026#34;ten\u0026#34;);?\u0026gt; 右键自定义 在设置外观-开发者设置-自定义输出body尾部添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; a {text-decoration: none;} div.usercm{background-repeat:no-repeat;background-position:center center;background-size:cover;background-color:#fff;font-size:13px!important;width:130px;-moz-box-shadow:1px 1px 3px rgba (0,0,0,.3);box-shadow:0px 0px 15px #333;position:absolute;display:none;z-index:10000;opacity:0.9; border-radius: 8px;} div.usercm ul{list-style-type:none;list-style-position:outside;margin:0px;padding:0px;display:block} div.usercm ul li{margin:0px;padding:0px;line-height:35px;} div.usercm ul li a{color:#666;padding:0 15px;display:block} div.usercm ul li a:hover{color:#fff;background:rgba(170,222,18,0.88)} div.usercm ul li a i{margin-right:10px} a.disabled{color:#c8c8c8!important;cursor:not-allowed} a.disabled:hover{background-color:rgba(255,11,11,0)!important} div.usercm{background:#fff !important;} \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;usercm\u0026#34; style=\u0026#34;left: 199px; top: 5px; display: none;\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://muyu.mobi/\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-home fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;首页\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; onclick=\u0026#34;getSelect();\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-copy fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;复制\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; onclick=\u0026#34;baiduSearch();\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-search fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;搜索\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:history.go(1);\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-arrow-right fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;前进\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:history.go(-1);\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-arrow-left fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;后退\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li style=\u0026#34;border-bottom:1px solid gray\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;javascript:window.location.reload();\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-refresh fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;重载网页\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://muyu.mobi/links.html\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-meh-o fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;和我当邻居\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://muyu.mobi/message.html\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-pencil-square-o fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;给我留言吧\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function(a) { a.extend({ mouseMoveShow: function(b) { var d = 0, c = 0, h = 0, k = 0, e = 0, f = 0; a(window).mousemove(function(g) { d = a(window).width(); c = a(window).height(); h = g.clientX; k = g.clientY; e = g.pageX; f = g.pageY; h + a(b).width() \u0026gt;= d \u0026amp;\u0026amp; (e = e - a(b).width() - 5); k + a(b).height() \u0026gt;= c \u0026amp;\u0026amp; (f = f - a(b).height() - 5); a(\u0026#34;html\u0026#34;).on({ contextmenu: function(c) { 3 == c.which \u0026amp;\u0026amp; a(b).css({ left: e, top: f }).show() }, click: function() { a(b).hide() } }) }) }, disabledContextMenu: function() { window.oncontextmenu = function() { return !1 } } }) })(jQuery); function getSelect() { \u0026#34;\u0026#34; == (window.getSelection ? window.getSelection() : document.selection.createRange().text) ? layer.msg(\u0026#34;啊噢...你没还没选择文字呢！\u0026#34;) : document.execCommand(\u0026#34;Copy\u0026#34;) } function baiduSearch() { var a = window.getSelection ? window.getSelection() : document.selection.createRange().text; \u0026#34;\u0026#34; == a ? layer.msg(\u0026#34;啊噢...你没还没选择文字呢！\u0026#34;) : window.open(\u0026#34;https://www.baidu.com/s?wd=\u0026#34; + a) } $(function() { for (var a = navigator.userAgent, b = \u0026#34;Android;iPhone;SymbianOS;Windows Phone;iPad;iPod\u0026#34;.split(\u0026#34;;\u0026#34;), d = !0, c = 0; c \u0026lt; b.length; c++) if (0 \u0026lt; a.indexOf(b[c])) { d = !1; break } d \u0026amp;\u0026amp; ($.mouseMoveShow(\u0026#34;.usercm\u0026#34;), $.disabledContextMenu()) }); \u0026lt;/script\u0026gt; 时光机添加置顶视频 在**/usr/themes/handsome/component/say.php**的?php if ($comments-\u0026gt;have()): ?\u0026gt; div class=”streamline b-l m-l-lg m-b padder-v”之后(大概202行)添加代码\n1 2 3 4 5 6 7 8 \u0026lt;!--视频--\u0026gt; \u0026lt;div id=\u0026#34;comment-867\u0026#34; class=\u0026#34;comment-body comment-parent comment-odd comment-by-author\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading pos-rlt b-b b-light\u0026#34;\u0026gt; \u0026lt;center\u0026gt;如此便好\u0026lt;/center\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;video src=\u0026#34;视频地址\u0026#34; style=\u0026#34;background-image:url(视频封面图);background-size: cover;\u0026#34; preload=\u0026#34;preload\u0026#34;\u0026gt;\u0026lt;/video\u0026gt;\u0026lt;div class=\u0026#34;play-button\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","description":"部署简洁，录入方便","id":17,"section":"posts","tags":["typecho","handsome","blog"],"title":"Typecho博客搭建","uri":"https://qqnv.com/zh/posts/typecho%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"网络七层模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 http属于应用层，无状态协议\nsocket属于传输层\nSocket what is Socket IP地址与端口的结合协议（RFC793） TCP/IP协议的总称，是网络API的集合实现 Socket的作用与组成 在网络传输中用于唯一标识两个端点之间的链接 端点：包括（IP+Port） 四个要素：客户端地址、客户端端口、服务器地址、服务器端口 Socket之TCP TCP是面向连接的通信协议 通过三次握手建立连接，通讯完成时拆除连接 由于TCP是面向连接的所以只能用于端到端的通讯 Socket之UDP UDP是面向无连接的通讯协议 UDP数据包括目的端口号和源端口号信息 ","description":"Socket relevant knowledge","id":18,"section":"posts","tags":["socket"],"title":"Socket","uri":"https://qqnv.com/zh/posts/socket/"},{"content":"Sample images from Pixabayhttps://pixabay.com)\n","description":"photo gallery","id":19,"section":"gallery","tags":null,"title":"Photo","uri":"https://qqnv.com/zh/gallery/photo/"}]